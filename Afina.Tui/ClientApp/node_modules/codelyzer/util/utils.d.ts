import { BooleanLiteral, ClassDeclaration, Decorator, Expression, ExpressionWithTypeArguments, Node, NodeArray, ObjectLiteralExpression, SourceFile } from 'typescript';
export declare enum Decorators {
    ContentChild = "ContentChild",
    ContentChildren = "ContentChildren",
    HostBinding = "HostBinding",
    HostListener = "HostListener",
    Input = "Input",
    Output = "Output",
    ViewChild = "ViewChild",
    ViewChildren = "ViewChildren"
}
export declare enum LifecycleInterfaces {
    AfterContentChecked = "AfterContentChecked",
    AfterContentInit = "AfterContentInit",
    AfterViewChecked = "AfterViewChecked",
    AfterViewInit = "AfterViewInit",
    OnChanges = "OnChanges",
    OnDestroy = "OnDestroy",
    OnInit = "OnInit",
    DoCheck = "DoCheck"
}
export declare enum LifecycleMethods {
    ngAfterContentChecked = "ngAfterContentChecked",
    ngAfterContentInit = "ngAfterContentInit",
    ngAfterViewChecked = "ngAfterViewChecked",
    ngAfterViewInit = "ngAfterViewInit",
    ngOnChanges = "ngOnChanges",
    ngOnDestroy = "ngOnDestroy",
    ngOnInit = "ngOnInit",
    ngDoCheck = "ngDoCheck"
}
export declare enum MetadataTypes {
    Component = "Component",
    Directive = "Directive",
    Injectable = "Injectable",
    Pipe = "Pipe",
    NgModule = "NgModule"
}
export declare type DecoratorKeys = keyof typeof Decorators;
export declare type LifecycleInterfaceKeys = keyof typeof LifecycleInterfaces;
export declare type LifecycleMethodKeys = keyof typeof LifecycleMethods;
export declare type MetadataTypeKeys = keyof typeof MetadataTypes;
export declare type MetadataTypeLifecycleMapper = Readonly<Record<MetadataTypes, typeof LIFECYCLE_METHODS>>;
export declare type MetadataTypeDecoratorMapper = Readonly<Record<MetadataTypes, typeof DECORATORS>>;
export declare const decoratorKeys: ReadonlyArray<"ContentChild" | "ContentChildren" | "HostBinding" | "HostListener" | "Input" | "Output" | "ViewChild" | "ViewChildren">;
export declare const lifecycleInterfaceKeys: ReadonlyArray<"AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "OnChanges" | "OnDestroy" | "OnInit" | "DoCheck">;
export declare const lifecycleMethodKeys: ReadonlyArray<"ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit" | "ngDoCheck">;
export declare const metadataTypeKeys: ReadonlyArray<"Component" | "Directive" | "Injectable" | "Pipe" | "NgModule">;
export declare const DECORATORS: ReadonlySet<DecoratorKeys>;
export declare const LIFECYCLE_INTERFACES: ReadonlySet<LifecycleInterfaceKeys>;
export declare const LIFECYCLE_METHODS: ReadonlySet<LifecycleMethodKeys>;
export declare const METADATA_TYPES: ReadonlySet<MetadataTypeKeys>;
export declare const METADATA_TYPE_DECORATOR_MAPPER: MetadataTypeDecoratorMapper;
export declare const METADATA_TYPE_LIFECYCLE_MAPPER: MetadataTypeLifecycleMapper;
export declare const getClassName: (node: Node) => string;
export declare const getDecorator: (node: ClassDeclaration, decoratorName: string) => Decorator;
export declare const getDecoratorArgument: (decorator: Decorator) => ObjectLiteralExpression;
export declare const getDecoratorPropertyInitializer: (decorator: Decorator, name: string) => Expression;
export declare const getDecoratorName: (decorator: Decorator) => string;
export declare const getNextToLastParentNode: (node: Node) => Node;
export declare const getComponentDecorator: (node: ClassDeclaration) => Decorator;
export declare const getDirectiveDecorator: (node: ClassDeclaration) => Decorator;
export declare const getInjectableDecorator: (node: ClassDeclaration) => Decorator;
export declare const getNgModuleDecorator: (node: ClassDeclaration) => Decorator;
export declare const getPipeDecorator: (node: ClassDeclaration) => Decorator;
export declare const getSymbolName: (expression: ExpressionWithTypeArguments) => string;
export declare const isNgDecorator: (value: string) => value is "ContentChild" | "ContentChildren" | "HostBinding" | "HostListener" | "Input" | "Output" | "ViewChild" | "ViewChildren";
export declare const isLifecycleInterface: (value: string) => value is "AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "OnChanges" | "OnDestroy" | "OnInit" | "DoCheck";
export declare const isLifecycleMethod: (value: string) => value is "ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit" | "ngDoCheck";
export declare const isMetadataType: (value: string) => value is MetadataTypes;
export declare const getDeclaredInterfaces: (node: ClassDeclaration) => NodeArray<ExpressionWithTypeArguments>;
export declare const getDeclaredInterfaceNames: (node: ClassDeclaration) => string[];
export declare const getDeclaredInterfaceName: (node: ClassDeclaration, value: string) => string;
export declare const getDeclaredLifecycleInterfaces: (node: ClassDeclaration) => ReadonlyArray<"AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "OnChanges" | "OnDestroy" | "OnInit" | "DoCheck">;
export declare const getLifecycleInterfaceByMethodName: (methodName: "ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit" | "ngDoCheck") => "AfterContentChecked" | "AfterContentInit" | "AfterViewChecked" | "AfterViewInit" | "OnChanges" | "OnDestroy" | "OnInit" | "DoCheck";
export declare const getDeclaredLifecycleMethods: (node: ClassDeclaration) => ReadonlyArray<"ngAfterContentChecked" | "ngAfterContentInit" | "ngAfterViewChecked" | "ngAfterViewInit" | "ngOnChanges" | "ngOnDestroy" | "ngOnInit" | "ngDoCheck">;
export declare const kebabToCamelCase: (value: string) => string;
export declare const isSameLine: (sourceFile: SourceFile, pos1: number, pos2: number) => boolean;
export declare const isBooleanLiteralLike: (node: Node) => node is BooleanLiteral;
export declare const isStringLiteralLike: (node: Node) => node is import("typescript").StringLiteralLike;
export declare const maybeNodeArray: <T extends Node>(nodes: NodeArray<T>) => ReadonlyArray<T>;
export declare const toTitleCase: (value: string) => string;
